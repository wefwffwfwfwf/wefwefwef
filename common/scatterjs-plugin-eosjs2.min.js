! function(t) {
    var r = {};

    function e(n) {
        if (r[n]) return r[n].exports;
        var o = r[n] = {
            i: n,
            l: !1,
            exports: {}
        };
        return t[n].call(o.exports, o, o.exports, e), o.l = !0, o.exports
    }
    e.m = t, e.c = r, e.d = function(t, r, n) {
        e.o(t, r) || Object.defineProperty(t, r, {
            enumerable: !0,
            get: n
        })
    }, e.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, e.t = function(t, r) {
        if (1 & r && (t = e(t)), 8 & r) return t;
        if (4 & r && "object" == typeof t && t && t.__esModule) return t;
        var n = Object.create(null);
        if (e.r(n), Object.defineProperty(n, "default", {
                enumerable: !0,
                value: t
            }), 2 & r && "string" != typeof t)
            for (var o in t) e.d(n, o, function(r) {
                return t[r]
            }.bind(null, o));
        return n
    }, e.n = function(t) {
        var r = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return e.d(r, "a", r), r
    }, e.o = function(t, r) {
        return Object.prototype.hasOwnProperty.call(t, r)
    }, e.p = "", e(e.s = 140)
}({
    0: function(t, r, e) {
        t.exports = e(27)
    },
    1: function(t, r) {
        function e(t, r, e, n, o, i, u) {
            try {
                var a = t[i](u),
                    f = a.value
            } catch (t) {
                return void e(t)
            }
            a.done ? r(f) : Promise.resolve(f).then(n, o)
        }
        t.exports = function(t) {
            return function() {
                var r = this,
                    n = arguments;
                return new Promise((function(o, i) {
                    var u = t.apply(r, n);

                    function a(t) {
                        e(u, o, i, a, f, "next", t)
                    }

                    function f(t) {
                        e(u, o, i, a, f, "throw", t)
                    }
                    a(void 0)
                }))
            }
        }
    },
    12: function(t, r, e) {
        "use strict";
        (function(t) {
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
             * @license  MIT
             */
            var n = e(39),
                o = e(40),
                i = e(29);

            function u() {
                return f.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
            }

            function a(t, r) {
                if (u() < r) throw new RangeError("Invalid typed array length");
                return f.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(r)).__proto__ = f.prototype : (null === t && (t = new f(r)), t.length = r), t
            }

            function f(t, r, e) {
                if (!(f.TYPED_ARRAY_SUPPORT || this instanceof f)) return new f(t, r, e);
                if ("number" == typeof t) {
                    if ("string" == typeof r) throw new Error("If encoding is specified then the first argument must be a string");
                    return h(this, t)
                }
                return s(this, t, r, e)
            }

            function s(t, r, e, n) {
                if ("number" == typeof r) throw new TypeError('"value" argument must not be a number');
                return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? function(t, r, e, n) {
                    if (r.byteLength, e < 0 || r.byteLength < e) throw new RangeError("'offset' is out of bounds");
                    if (r.byteLength < e + (n || 0)) throw new RangeError("'length' is out of bounds");
                    r = void 0 === e && void 0 === n ? new Uint8Array(r) : void 0 === n ? new Uint8Array(r, e) : new Uint8Array(r, e, n);
                    f.TYPED_ARRAY_SUPPORT ? (t = r).__proto__ = f.prototype : t = l(t, r);
                    return t
                }(t, r, e, n) : "string" == typeof r ? function(t, r, e) {
                    "string" == typeof e && "" !== e || (e = "utf8");
                    if (!f.isEncoding(e)) throw new TypeError('"encoding" must be a valid string encoding');
                    var n = 0 | y(r, e),
                        o = (t = a(t, n)).write(r, e);
                    o !== n && (t = t.slice(0, o));
                    return t
                }(t, r, e) : function(t, r) {
                    if (f.isBuffer(r)) {
                        var e = 0 | p(r.length);
                        return 0 === (t = a(t, e)).length ? t : (r.copy(t, 0, 0, e), t)
                    }
                    if (r) {
                        if ("undefined" != typeof ArrayBuffer && r.buffer instanceof ArrayBuffer || "length" in r) return "number" != typeof r.length || (n = r.length) != n ? a(t, 0) : l(t, r);
                        if ("Buffer" === r.type && i(r.data)) return l(t, r.data)
                    }
                    var n;
                    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
                }(t, r)
            }

            function c(t) {
                if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
                if (t < 0) throw new RangeError('"size" argument must not be negative')
            }

            function h(t, r) {
                if (c(r), t = a(t, r < 0 ? 0 : 0 | p(r)), !f.TYPED_ARRAY_SUPPORT)
                    for (var e = 0; e < r; ++e) t[e] = 0;
                return t
            }

            function l(t, r) {
                var e = r.length < 0 ? 0 : 0 | p(r.length);
                t = a(t, e);
                for (var n = 0; n < e; n += 1) t[n] = 255 & r[n];
                return t
            }

            function p(t) {
                if (t >= u()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + u().toString(16) + " bytes");
                return 0 | t
            }

            function y(t, r) {
                if (f.isBuffer(t)) return t.length;
                if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
                "string" != typeof t && (t = "" + t);
                var e = t.length;
                if (0 === e) return 0;
                for (var n = !1;;) switch (r) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return e;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                        return F(t).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * e;
                    case "hex":
                        return e >>> 1;
                    case "base64":
                        return z(t).length;
                    default:
                        if (n) return F(t).length;
                        r = ("" + r).toLowerCase(), n = !0
                }
            }

            function g(t, r, e) {
                var n = !1;
                if ((void 0 === r || r < 0) && (r = 0), r > this.length) return "";
                if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return "";
                if ((e >>>= 0) <= (r >>>= 0)) return "";
                for (t || (t = "utf8");;) switch (t) {
                    case "hex":
                        return O(this, r, e);
                    case "utf8":
                    case "utf-8":
                        return R(this, r, e);
                    case "ascii":
                        return T(this, r, e);
                    case "latin1":
                    case "binary":
                        return B(this, r, e);
                    case "base64":
                        return x(this, r, e);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return L(this, r, e);
                    default:
                        if (n) throw new TypeError("Unknown encoding: " + t);
                        t = (t + "").toLowerCase(), n = !0
                }
            }

            function d(t, r, e) {
                var n = t[r];
                t[r] = t[e], t[e] = n
            }

            function v(t, r, e, n, o) {
                if (0 === t.length) return -1;
                if ("string" == typeof e ? (n = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, isNaN(e) && (e = o ? 0 : t.length - 1), e < 0 && (e = t.length + e), e >= t.length) {
                    if (o) return -1;
                    e = t.length - 1
                } else if (e < 0) {
                    if (!o) return -1;
                    e = 0
                }
                if ("string" == typeof r && (r = f.from(r, n)), f.isBuffer(r)) return 0 === r.length ? -1 : w(t, r, e, n, o);
                if ("number" == typeof r) return r &= 255, f.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, r, e) : Uint8Array.prototype.lastIndexOf.call(t, r, e) : w(t, [r], e, n, o);
                throw new TypeError("val must be string, number or Buffer")
            }

            function w(t, r, e, n, o) {
                var i, u = 1,
                    a = t.length,
                    f = r.length;
                if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                    if (t.length < 2 || r.length < 2) return -1;
                    u = 2, a /= 2, f /= 2, e /= 2
                }

                function s(t, r) {
                    return 1 === u ? t[r] : t.readUInt16BE(r * u)
                }
                if (o) {
                    var c = -1;
                    for (i = e; i < a; i++)
                        if (s(t, i) === s(r, -1 === c ? 0 : i - c)) {
                            if (-1 === c && (c = i), i - c + 1 === f) return c * u
                        } else -1 !== c && (i -= i - c), c = -1
                } else
                    for (e + f > a && (e = a - f), i = e; i >= 0; i--) {
                        for (var h = !0, l = 0; l < f; l++)
                            if (s(t, i + l) !== s(r, l)) {
                                h = !1;
                                break
                            }
                        if (h) return i
                    }
                return -1
            }

            function m(t, r, e, n) {
                e = Number(e) || 0;
                var o = t.length - e;
                n ? (n = Number(n)) > o && (n = o) : n = o;
                var i = r.length;
                if (i % 2 != 0) throw new TypeError("Invalid hex string");
                n > i / 2 && (n = i / 2);
                for (var u = 0; u < n; ++u) {
                    var a = parseInt(r.substr(2 * u, 2), 16);
                    if (isNaN(a)) return u;
                    t[e + u] = a
                }
                return u
            }

            function b(t, r, e, n) {
                return q(F(r, t.length - e), t, e, n)
            }

            function E(t, r, e, n) {
                return q(function(t) {
                    for (var r = [], e = 0; e < t.length; ++e) r.push(255 & t.charCodeAt(e));
                    return r
                }(r), t, e, n)
            }

            function A(t, r, e, n) {
                return E(t, r, e, n)
            }

            function _(t, r, e, n) {
                return q(z(r), t, e, n)
            }

            function P(t, r, e, n) {
                return q(function(t, r) {
                    for (var e, n, o, i = [], u = 0; u < t.length && !((r -= 2) < 0); ++u) e = t.charCodeAt(u), n = e >> 8, o = e % 256, i.push(o), i.push(n);
                    return i
                }(r, t.length - e), t, e, n)
            }

            function x(t, r, e) {
                return 0 === r && e === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(r, e))
            }

            function R(t, r, e) {
                e = Math.min(t.length, e);
                for (var n = [], o = r; o < e;) {
                    var i, u, a, f, s = t[o],
                        c = null,
                        h = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
                    if (o + h <= e) switch (h) {
                        case 1:
                            s < 128 && (c = s);
                            break;
                        case 2:
                            128 == (192 & (i = t[o + 1])) && (f = (31 & s) << 6 | 63 & i) > 127 && (c = f);
                            break;
                        case 3:
                            i = t[o + 1], u = t[o + 2], 128 == (192 & i) && 128 == (192 & u) && (f = (15 & s) << 12 | (63 & i) << 6 | 63 & u) > 2047 && (f < 55296 || f > 57343) && (c = f);
                            break;
                        case 4:
                            i = t[o + 1], u = t[o + 2], a = t[o + 3], 128 == (192 & i) && 128 == (192 & u) && 128 == (192 & a) && (f = (15 & s) << 18 | (63 & i) << 12 | (63 & u) << 6 | 63 & a) > 65535 && f < 1114112 && (c = f)
                    }
                    null === c ? (c = 65533, h = 1) : c > 65535 && (c -= 65536, n.push(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), n.push(c), o += h
                }
                return function(t) {
                    var r = t.length;
                    if (r <= S) return String.fromCharCode.apply(String, t);
                    var e = "",
                        n = 0;
                    for (; n < r;) e += String.fromCharCode.apply(String, t.slice(n, n += S));
                    return e
                }(n)
            }
            r.Buffer = f, r.SlowBuffer = function(t) {
                +t != t && (t = 0);
                return f.alloc(+t)
            }, r.INSPECT_MAX_BYTES = 50, f.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function() {
                try {
                    var t = new Uint8Array(1);
                    return t.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42
                        }
                    }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
                } catch (t) {
                    return !1
                }
            }(), r.kMaxLength = u(), f.poolSize = 8192, f._augment = function(t) {
                return t.__proto__ = f.prototype, t
            }, f.from = function(t, r, e) {
                return s(null, t, r, e)
            }, f.TYPED_ARRAY_SUPPORT && (f.prototype.__proto__ = Uint8Array.prototype, f.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && f[Symbol.species] === f && Object.defineProperty(f, Symbol.species, {
                value: null,
                configurable: !0
            })), f.alloc = function(t, r, e) {
                return function(t, r, e, n) {
                    return c(r), r <= 0 ? a(t, r) : void 0 !== e ? "string" == typeof n ? a(t, r).fill(e, n) : a(t, r).fill(e) : a(t, r)
                }(null, t, r, e)
            }, f.allocUnsafe = function(t) {
                return h(null, t)
            }, f.allocUnsafeSlow = function(t) {
                return h(null, t)
            }, f.isBuffer = function(t) {
                return !(null == t || !t._isBuffer)
            }, f.compare = function(t, r) {
                if (!f.isBuffer(t) || !f.isBuffer(r)) throw new TypeError("Arguments must be Buffers");
                if (t === r) return 0;
                for (var e = t.length, n = r.length, o = 0, i = Math.min(e, n); o < i; ++o)
                    if (t[o] !== r[o]) {
                        e = t[o], n = r[o];
                        break
                    }
                return e < n ? -1 : n < e ? 1 : 0
            }, f.isEncoding = function(t) {
                switch (String(t).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, f.concat = function(t, r) {
                if (!i(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === t.length) return f.alloc(0);
                var e;
                if (void 0 === r)
                    for (r = 0, e = 0; e < t.length; ++e) r += t[e].length;
                var n = f.allocUnsafe(r),
                    o = 0;
                for (e = 0; e < t.length; ++e) {
                    var u = t[e];
                    if (!f.isBuffer(u)) throw new TypeError('"list" argument must be an Array of Buffers');
                    u.copy(n, o), o += u.length
                }
                return n
            }, f.byteLength = y, f.prototype._isBuffer = !0, f.prototype.swap16 = function() {
                var t = this.length;
                if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (var r = 0; r < t; r += 2) d(this, r, r + 1);
                return this
            }, f.prototype.swap32 = function() {
                var t = this.length;
                if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (var r = 0; r < t; r += 4) d(this, r, r + 3), d(this, r + 1, r + 2);
                return this
            }, f.prototype.swap64 = function() {
                var t = this.length;
                if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (var r = 0; r < t; r += 8) d(this, r, r + 7), d(this, r + 1, r + 6), d(this, r + 2, r + 5), d(this, r + 3, r + 4);
                return this
            }, f.prototype.toString = function() {
                var t = 0 | this.length;
                return 0 === t ? "" : 0 === arguments.length ? R(this, 0, t) : g.apply(this, arguments)
            }, f.prototype.equals = function(t) {
                if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === f.compare(this, t)
            }, f.prototype.inspect = function() {
                var t = "",
                    e = r.INSPECT_MAX_BYTES;
                return this.length > 0 && (t = this.toString("hex", 0, e).match(/.{2}/g).join(" "), this.length > e && (t += " ... ")), "<Buffer " + t + ">"
            }, f.prototype.compare = function(t, r, e, n, o) {
                if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                if (void 0 === r && (r = 0), void 0 === e && (e = t ? t.length : 0), void 0 === n && (n = 0), void 0 === o && (o = this.length), r < 0 || e > t.length || n < 0 || o > this.length) throw new RangeError("out of range index");
                if (n >= o && r >= e) return 0;
                if (n >= o) return -1;
                if (r >= e) return 1;
                if (this === t) return 0;
                for (var i = (o >>>= 0) - (n >>>= 0), u = (e >>>= 0) - (r >>>= 0), a = Math.min(i, u), s = this.slice(n, o), c = t.slice(r, e), h = 0; h < a; ++h)
                    if (s[h] !== c[h]) {
                        i = s[h], u = c[h];
                        break
                    }
                return i < u ? -1 : u < i ? 1 : 0
            }, f.prototype.includes = function(t, r, e) {
                return -1 !== this.indexOf(t, r, e)
            }, f.prototype.indexOf = function(t, r, e) {
                return v(this, t, r, e, !0)
            }, f.prototype.lastIndexOf = function(t, r, e) {
                return v(this, t, r, e, !1)
            }, f.prototype.write = function(t, r, e, n) {
                if (void 0 === r) n = "utf8", e = this.length, r = 0;
                else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0;
                else {
                    if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    r |= 0, isFinite(e) ? (e |= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0)
                }
                var o = this.length - r;
                if ((void 0 === e || e > o) && (e = o), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                n || (n = "utf8");
                for (var i = !1;;) switch (n) {
                    case "hex":
                        return m(this, t, r, e);
                    case "utf8":
                    case "utf-8":
                        return b(this, t, r, e);
                    case "ascii":
                        return E(this, t, r, e);
                    case "latin1":
                    case "binary":
                        return A(this, t, r, e);
                    case "base64":
                        return _(this, t, r, e);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return P(this, t, r, e);
                    default:
                        if (i) throw new TypeError("Unknown encoding: " + n);
                        n = ("" + n).toLowerCase(), i = !0
                }
            }, f.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            };
            var S = 4096;

            function T(t, r, e) {
                var n = "";
                e = Math.min(t.length, e);
                for (var o = r; o < e; ++o) n += String.fromCharCode(127 & t[o]);
                return n
            }

            function B(t, r, e) {
                var n = "";
                e = Math.min(t.length, e);
                for (var o = r; o < e; ++o) n += String.fromCharCode(t[o]);
                return n
            }

            function O(t, r, e) {
                var n = t.length;
                (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n);
                for (var o = "", i = r; i < e; ++i) o += D(t[i]);
                return o
            }

            function L(t, r, e) {
                for (var n = t.slice(r, e), o = "", i = 0; i < n.length; i += 2) o += String.fromCharCode(n[i] + 256 * n[i + 1]);
                return o
            }

            function U(t, r, e) {
                if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
                if (t + r > e) throw new RangeError("Trying to access beyond buffer length")
            }

            function k(t, r, e, n, o, i) {
                if (!f.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > o || r < i) throw new RangeError('"value" argument is out of bounds');
                if (e + n > t.length) throw new RangeError("Index out of range")
            }

            function I(t, r, e, n) {
                r < 0 && (r = 65535 + r + 1);
                for (var o = 0, i = Math.min(t.length - e, 2); o < i; ++o) t[e + o] = (r & 255 << 8 * (n ? o : 1 - o)) >>> 8 * (n ? o : 1 - o)
            }

            function Y(t, r, e, n) {
                r < 0 && (r = 4294967295 + r + 1);
                for (var o = 0, i = Math.min(t.length - e, 4); o < i; ++o) t[e + o] = r >>> 8 * (n ? o : 3 - o) & 255
            }

            function C(t, r, e, n, o, i) {
                if (e + n > t.length) throw new RangeError("Index out of range");
                if (e < 0) throw new RangeError("Index out of range")
            }

            function j(t, r, e, n, i) {
                return i || C(t, 0, e, 4), o.write(t, r, e, n, 23, 4), e + 4
            }

            function M(t, r, e, n, i) {
                return i || C(t, 0, e, 8), o.write(t, r, e, n, 52, 8), e + 8
            }
            f.prototype.slice = function(t, r) {
                var e, n = this.length;
                if ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (r = void 0 === r ? n : ~~r) < 0 ? (r += n) < 0 && (r = 0) : r > n && (r = n), r < t && (r = t), f.TYPED_ARRAY_SUPPORT)(e = this.subarray(t, r)).__proto__ = f.prototype;
                else {
                    var o = r - t;
                    e = new f(o, void 0);
                    for (var i = 0; i < o; ++i) e[i] = this[i + t]
                }
                return e
            }, f.prototype.readUIntLE = function(t, r, e) {
                t |= 0, r |= 0, e || U(t, r, this.length);
                for (var n = this[t], o = 1, i = 0; ++i < r && (o *= 256);) n += this[t + i] * o;
                return n
            }, f.prototype.readUIntBE = function(t, r, e) {
                t |= 0, r |= 0, e || U(t, r, this.length);
                for (var n = this[t + --r], o = 1; r > 0 && (o *= 256);) n += this[t + --r] * o;
                return n
            }, f.prototype.readUInt8 = function(t, r) {
                return r || U(t, 1, this.length), this[t]
            }, f.prototype.readUInt16LE = function(t, r) {
                return r || U(t, 2, this.length), this[t] | this[t + 1] << 8
            }, f.prototype.readUInt16BE = function(t, r) {
                return r || U(t, 2, this.length), this[t] << 8 | this[t + 1]
            }, f.prototype.readUInt32LE = function(t, r) {
                return r || U(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
            }, f.prototype.readUInt32BE = function(t, r) {
                return r || U(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
            }, f.prototype.readIntLE = function(t, r, e) {
                t |= 0, r |= 0, e || U(t, r, this.length);
                for (var n = this[t], o = 1, i = 0; ++i < r && (o *= 256);) n += this[t + i] * o;
                return n >= (o *= 128) && (n -= Math.pow(2, 8 * r)), n
            }, f.prototype.readIntBE = function(t, r, e) {
                t |= 0, r |= 0, e || U(t, r, this.length);
                for (var n = r, o = 1, i = this[t + --n]; n > 0 && (o *= 256);) i += this[t + --n] * o;
                return i >= (o *= 128) && (i -= Math.pow(2, 8 * r)), i
            }, f.prototype.readInt8 = function(t, r) {
                return r || U(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
            }, f.prototype.readInt16LE = function(t, r) {
                r || U(t, 2, this.length);
                var e = this[t] | this[t + 1] << 8;
                return 32768 & e ? 4294901760 | e : e
            }, f.prototype.readInt16BE = function(t, r) {
                r || U(t, 2, this.length);
                var e = this[t + 1] | this[t] << 8;
                return 32768 & e ? 4294901760 | e : e
            }, f.prototype.readInt32LE = function(t, r) {
                return r || U(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
            }, f.prototype.readInt32BE = function(t, r) {
                return r || U(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
            }, f.prototype.readFloatLE = function(t, r) {
                return r || U(t, 4, this.length), o.read(this, t, !0, 23, 4)
            }, f.prototype.readFloatBE = function(t, r) {
                return r || U(t, 4, this.length), o.read(this, t, !1, 23, 4)
            }, f.prototype.readDoubleLE = function(t, r) {
                return r || U(t, 8, this.length), o.read(this, t, !0, 52, 8)
            }, f.prototype.readDoubleBE = function(t, r) {
                return r || U(t, 8, this.length), o.read(this, t, !1, 52, 8)
            }, f.prototype.writeUIntLE = function(t, r, e, n) {
                (t = +t, r |= 0, e |= 0, n) || k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                var o = 1,
                    i = 0;
                for (this[r] = 255 & t; ++i < e && (o *= 256);) this[r + i] = t / o & 255;
                return r + e
            }, f.prototype.writeUIntBE = function(t, r, e, n) {
                (t = +t, r |= 0, e |= 0, n) || k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                var o = e - 1,
                    i = 1;
                for (this[r + o] = 255 & t; --o >= 0 && (i *= 256);) this[r + o] = t / i & 255;
                return r + e
            }, f.prototype.writeUInt8 = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 1, 255, 0), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[r] = 255 & t, r + 1
            }, f.prototype.writeUInt16LE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : I(this, t, r, !0), r + 2
            }, f.prototype.writeUInt16BE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : I(this, t, r, !1), r + 2
            }, f.prototype.writeUInt32LE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t) : Y(this, t, r, !0), r + 4
            }, f.prototype.writeUInt32BE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : Y(this, t, r, !1), r + 4
            }, f.prototype.writeIntLE = function(t, r, e, n) {
                if (t = +t, r |= 0, !n) {
                    var o = Math.pow(2, 8 * e - 1);
                    k(this, t, r, e, o - 1, -o)
                }
                var i = 0,
                    u = 1,
                    a = 0;
                for (this[r] = 255 & t; ++i < e && (u *= 256);) t < 0 && 0 === a && 0 !== this[r + i - 1] && (a = 1), this[r + i] = (t / u >> 0) - a & 255;
                return r + e
            }, f.prototype.writeIntBE = function(t, r, e, n) {
                if (t = +t, r |= 0, !n) {
                    var o = Math.pow(2, 8 * e - 1);
                    k(this, t, r, e, o - 1, -o)
                }
                var i = e - 1,
                    u = 1,
                    a = 0;
                for (this[r + i] = 255 & t; --i >= 0 && (u *= 256);) t < 0 && 0 === a && 0 !== this[r + i + 1] && (a = 1), this[r + i] = (t / u >> 0) - a & 255;
                return r + e
            }, f.prototype.writeInt8 = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 1, 127, -128), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1
            }, f.prototype.writeInt16LE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : I(this, t, r, !0), r + 2
            }, f.prototype.writeInt16BE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : I(this, t, r, !1), r + 2
            }, f.prototype.writeInt32LE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 4, 2147483647, -2147483648), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24) : Y(this, t, r, !0), r + 4
            }, f.prototype.writeInt32BE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : Y(this, t, r, !1), r + 4
            }, f.prototype.writeFloatLE = function(t, r, e) {
                return j(this, t, r, !0, e)
            }, f.prototype.writeFloatBE = function(t, r, e) {
                return j(this, t, r, !1, e)
            }, f.prototype.writeDoubleLE = function(t, r, e) {
                return M(this, t, r, !0, e)
            }, f.prototype.writeDoubleBE = function(t, r, e) {
                return M(this, t, r, !1, e)
            }, f.prototype.copy = function(t, r, e, n) {
                if (e || (e = 0), n || 0 === n || (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < e && (n = e), n === e) return 0;
                if (0 === t.length || 0 === this.length) return 0;
                if (r < 0) throw new RangeError("targetStart out of bounds");
                if (e < 0 || e >= this.length) throw new RangeError("sourceStart out of bounds");
                if (n < 0) throw new RangeError("sourceEnd out of bounds");
                n > this.length && (n = this.length), t.length - r < n - e && (n = t.length - r + e);
                var o, i = n - e;
                if (this === t && e < r && r < n)
                    for (o = i - 1; o >= 0; --o) t[o + r] = this[o + e];
                else if (i < 1e3 || !f.TYPED_ARRAY_SUPPORT)
                    for (o = 0; o < i; ++o) t[o + r] = this[o + e];
                else Uint8Array.prototype.set.call(t, this.subarray(e, e + i), r);
                return i
            }, f.prototype.fill = function(t, r, e, n) {
                if ("string" == typeof t) {
                    if ("string" == typeof r ? (n = r, r = 0, e = this.length) : "string" == typeof e && (n = e, e = this.length), 1 === t.length) {
                        var o = t.charCodeAt(0);
                        o < 256 && (t = o)
                    }
                    if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
                    if ("string" == typeof n && !f.isEncoding(n)) throw new TypeError("Unknown encoding: " + n)
                } else "number" == typeof t && (t &= 255);
                if (r < 0 || this.length < r || this.length < e) throw new RangeError("Out of range index");
                if (e <= r) return this;
                var i;
                if (r >>>= 0, e = void 0 === e ? this.length : e >>> 0, t || (t = 0), "number" == typeof t)
                    for (i = r; i < e; ++i) this[i] = t;
                else {
                    var u = f.isBuffer(t) ? t : F(new f(t, n).toString()),
                        a = u.length;
                    for (i = 0; i < e - r; ++i) this[i + r] = u[i % a]
                }
                return this
            };
            var N = /[^+\/0-9A-Za-z-_]/g;

            function D(t) {
                return t < 16 ? "0" + t.toString(16) : t.toString(16)
            }

            function F(t, r) {
                var e;
                r = r || 1 / 0;
                for (var n = t.length, o = null, i = [], u = 0; u < n; ++u) {
                    if ((e = t.charCodeAt(u)) > 55295 && e < 57344) {
                        if (!o) {
                            if (e > 56319) {
                                (r -= 3) > -1 && i.push(239, 191, 189);
                                continue
                            }
                            if (u + 1 === n) {
                                (r -= 3) > -1 && i.push(239, 191, 189);
                                continue
                            }
                            o = e;
                            continue
                        }
                        if (e < 56320) {
                            (r -= 3) > -1 && i.push(239, 191, 189), o = e;
                            continue
                        }
                        e = 65536 + (o - 55296 << 10 | e - 56320)
                    } else o && (r -= 3) > -1 && i.push(239, 191, 189);
                    if (o = null, e < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(e)
                    } else if (e < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(e >> 6 | 192, 63 & e | 128)
                    } else if (e < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128)
                    } else {
                        if (!(e < 1114112)) throw new Error("Invalid code point");
                        if ((r -= 4) < 0) break;
                        i.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128)
                    }
                }
                return i
            }

            function z(t) {
                return n.toByteArray(function(t) {
                    if ((t = function(t) {
                            return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
                        }(t).replace(N, "")).length < 2) return "";
                    for (; t.length % 4 != 0;) t += "=";
                    return t
                }(t))
            }

            function q(t, r, e, n) {
                for (var o = 0; o < n && !(o + e >= r.length || o >= t.length); ++o) r[o + e] = t[o];
                return o
            }
        }).call(this, e(7))
    },
    13: function(t, r) {
        function e(t) {
            return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function n(r) {
            return "function" == typeof Symbol && "symbol" === e(Symbol.iterator) ? t.exports = n = function(t) {
                return e(t)
            } : t.exports = n = function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : e(t)
            }, n(r)
        }
        t.exports = n
    },
    140: function(t, r, e) {
        "use strict";
        e.r(r),
            function(t) {
                e.d(r, "default", (function() {
                    return A
                }));
                var n = e(13),
                    o = e.n(n),
                    i = e(0),
                    u = e.n(i),
                    a = e(1),
                    f = e.n(a),
                    s = e(4),
                    c = e.n(s),
                    h = e(5),
                    l = e.n(h),
                    p = e(6),
                    y = e.n(p),
                    g = e(8),
                    d = e.n(g),
                    v = e(9),
                    w = e.n(v),
                    m = e(2),
                    b = m.SocketService,
                    E = function(t, r) {
                        return new Proxy(t, r)
                    },
                    A = function(r) {
                        function e() {
                            return c()(this, e), y()(this, d()(e).call(this, m.Blockchains.EOS, m.PluginTypes.BLOCKCHAIN_SUPPORT))
                        }
                        return w()(e, r), l()(e, [{
                            key: "setSocketService",
                            value: function(t) {
                                b = t
                            }
                        }, {
                            key: "hookProvider",
                            value: function(r) {
                                var e, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
                                return r = m.Network.fromJson(r), {
                                    requiredFields: {},
                                    getAvailableKeys: function() {
                                        var t = f()(u.a.mark((function t() {
                                            return u.a.wrap((function(t) {
                                                for (;;) switch (t.prev = t.next) {
                                                    case 0:
                                                        return t.next = 2, b.sendApiRequest({
                                                            type: "identityFromPermissions",
                                                            payload: {}
                                                        }).then((function(t) {
                                                            return t ? t.accounts.filter((function(t) {
                                                                return t.blockchain === m.Blockchains.EOS
                                                            })).map((function(t) {
                                                                return t.publicKey
                                                            })) : []
                                                        }));
                                                    case 2:
                                                        return t.abrupt("return", t.sent);
                                                    case 3:
                                                    case "end":
                                                        return t.stop()
                                                }
                                            }), t)
                                        })));
                                        return function() {
                                            return t.apply(this, arguments)
                                        }
                                    }(),
                                    sign: (e = f()(u.a.mark((function e(o) {
                                        var i;
                                        return u.a.wrap((function(e) {
                                            for (;;) switch (e.prev = e.next) {
                                                case 0:
                                                    return i = n ? n() : {}, o.serializedTransaction = t.from(o.serializedTransaction).toString("hex"), e.abrupt("return", new Promise(function() {
                                                        var e = f()(u.a.mark((function e(n, a) {
                                                            return u.a.wrap((function(e) {
                                                                for (;;) switch (e.prev = e.next) {
                                                                    case 0:
                                                                        b.sendApiRequest({
                                                                            type: "requestSignature",
                                                                            payload: {
                                                                                transaction: o,
                                                                                blockchain: m.Blockchains.EOS,
                                                                                network: r,
                                                                                requiredFields: i
                                                                            }
                                                                        }).then((function(r) {
                                                                            n({
                                                                                signatures: r.signatures,
                                                                                serializedTransaction: t.from(o.serializedTransaction, "hex")
                                                                            })
                                                                        })).catch((function(t) {
                                                                            return a(t)
                                                                        }));
                                                                    case 1:
                                                                    case "end":
                                                                        return e.stop()
                                                                }
                                                            }), e)
                                                        })));
                                                        return function() {
                                                            return e.apply(this, arguments)
                                                        }
                                                    }()));
                                                case 3:
                                                case "end":
                                                    return e.stop()
                                            }
                                        }), e)
                                    }))), function() {
                                        return e.apply(this, arguments)
                                    })
                                }
                            }
                        }, {
                            key: "multiHook",
                            value: function(r, e) {
                                var n, i = this.eosHook(r);
                                return Array.isArray(e) || (e = [e]), {
                                    getAvailableKeys: function() {
                                        var t = f()(u.a.mark((function t() {
                                            var r, n;
                                            return u.a.wrap((function(t) {
                                                for (;;) switch (t.prev = t.next) {
                                                    case 0:
                                                        return t.prev = 0, t.next = 3, i.getAvailableKeys();
                                                    case 3:
                                                        return r = t.sent, n = [], t.next = 7, Promise.all(e.map(function() {
                                                            var t = f()(u.a.mark((function t(r) {
                                                                return u.a.wrap((function(t) {
                                                                    for (;;) switch (t.prev = t.next) {
                                                                        case 0:
                                                                            return t.next = 2, r.getAvailableKeys().then((function(t) {
                                                                                t.map((function(t) {
                                                                                    return n.push(t)
                                                                                }))
                                                                            }));
                                                                        case 2:
                                                                            return t.abrupt("return", !0);
                                                                        case 3:
                                                                        case "end":
                                                                            return t.stop()
                                                                    }
                                                                }), t)
                                                            })));
                                                            return function() {
                                                                return t.apply(this, arguments)
                                                            }
                                                        }()));
                                                    case 7:
                                                        return t.abrupt("return", r.concat(n));
                                                    case 10:
                                                        throw t.prev = 10, t.t0 = t.catch(0), new Error(t.t0);
                                                    case 13:
                                                    case "end":
                                                        return t.stop()
                                                }
                                            }), t, null, [
                                                [0, 10]
                                            ])
                                        })));
                                        return function() {
                                            return t.apply(this, arguments)
                                        }
                                    }(),
                                    sign: (n = f()(u.a.mark((function n(a) {
                                        var s, c, h, l, p;
                                        return u.a.wrap((function(n) {
                                            for (;;) switch (n.prev = n.next) {
                                                case 0:
                                                    return n.prev = 0, s = t.from(a.serializedTransaction, "hex"), c = function() {
                                                        var t = f()(u.a.mark((function t(e) {
                                                            return u.a.wrap((function(t) {
                                                                for (;;) switch (t.prev = t.next) {
                                                                    case 0:
                                                                        return t.t0 = a.abis, t.t1 = r.chainId, t.next = 4, e.getAvailableKeys();
                                                                    case 4:
                                                                        return t.t2 = t.sent, t.t3 = s, t.abrupt("return", {
                                                                            abis: t.t0,
                                                                            chainId: t.t1,
                                                                            requiredKeys: t.t2,
                                                                            serializedTransaction: t.t3
                                                                        });
                                                                    case 7:
                                                                    case "end":
                                                                        return t.stop()
                                                                }
                                                            }), t)
                                                        })));
                                                        return function() {
                                                            return t.apply(this, arguments)
                                                        }
                                                    }(), h = function(t) {
                                                        return "object" === o()(t) && t.hasOwnProperty("signatures") ? t.signatures : t
                                                    }, n.t0 = i, n.next = 7, c(i);
                                                case 7:
                                                    return n.t1 = n.sent, n.t2 = function(t) {
                                                        return h(t)
                                                    }, n.next = 11, n.t0.sign.call(n.t0, n.t1).then(n.t2);
                                                case 11:
                                                    return l = n.sent, p = [], n.next = 15, Promise.all(e.map(function() {
                                                        var t = f()(u.a.mark((function t(r) {
                                                            return u.a.wrap((function(t) {
                                                                for (;;) switch (t.prev = t.next) {
                                                                    case 0:
                                                                        return t.t0 = r, t.next = 3, c(r);
                                                                    case 3:
                                                                        return t.t1 = t.sent, t.t2 = function(t) {
                                                                            h(t).map((function(t) {
                                                                                return p.push(t)
                                                                            }))
                                                                        }, t.next = 7, t.t0.sign.call(t.t0, t.t1).then(t.t2);
                                                                    case 7:
                                                                        return t.abrupt("return", !0);
                                                                    case 8:
                                                                    case "end":
                                                                        return t.stop()
                                                                }
                                                            }), t)
                                                        })));
                                                        return function() {
                                                            return t.apply(this, arguments)
                                                        }
                                                    }()));
                                                case 15:
                                                    return n.abrupt("return", {
                                                        signatures: l.concat(p),
                                                        serializedTransaction: s
                                                    });
                                                case 18:
                                                    throw n.prev = 18, n.t3 = n.catch(0), new Error(n.t3);
                                                case 21:
                                                case "end":
                                                    return n.stop()
                                            }
                                        }), n, null, [
                                            [0, 18]
                                        ])
                                    }))), function() {
                                        return n.apply(this, arguments)
                                    })
                                }
                            }
                        }, {
                            key: "signatureProvider",
                            value: function() {
                                var t = this;
                                0 >= arguments.length || arguments[0];
                                return function(r, e) {
                                    var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
                                    r = m.Network.fromJson(r);
                                    var o = {},
                                        i = function() {
                                            return o
                                        },
                                        u = t.hookProvider(r, i);
                                    return E(new e(Object.assign(n, {
                                        signatureProvider: u
                                    })), {
                                        get: function(t, r) {
                                            return function() {
                                                if (void 0 === t[r]) throw new Error("".concat(r, " does not exist on the eosjs.Api() object."));
                                                for (var e = arguments.length, n = Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                                                var u = n.find((function(t) {
                                                    return t.hasOwnProperty("requiredFields")
                                                }));
                                                return o = u ? u.requiredFields : {}, t[r].apply(t, n)
                                            }
                                        }
                                    })
                                }
                            }
                        }]), e
                    }(m.Plugin);
                "undefined" != typeof window && (window.ScatterEOS = A)
            }.call(this, e(12).Buffer)
    },
    2: function(t, r) {
        t.exports = ScatterJS
    },
    23: function(t, r) {
        t.exports = function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }
    },
    24: function(t, r) {
        function e(r, n) {
            return t.exports = e = Object.setPrototypeOf || function(t, r) {
                return t.__proto__ = r, t
            }, e(r, n)
        }
        t.exports = e
    },
    27: function(t, r, e) {
        var n = function(t) {
            "use strict";
            var r, e = Object.prototype,
                n = e.hasOwnProperty,
                o = "function" == typeof Symbol ? Symbol : {},
                i = o.iterator || "@@iterator",
                u = o.asyncIterator || "@@asyncIterator",
                a = o.toStringTag || "@@toStringTag";

            function f(t, r, e, n) {
                var o = r && r.prototype instanceof g ? r : g,
                    i = Object.create(o.prototype),
                    u = new S(n || []);
                return i._invoke = function(t, r, e) {
                    var n = c;
                    return function(o, i) {
                        if (n === l) throw new Error("Generator is already running");
                        if (n === p) {
                            if ("throw" === o) throw i;
                            return B()
                        }
                        for (e.method = o, e.arg = i;;) {
                            var u = e.delegate;
                            if (u) {
                                var a = P(u, e);
                                if (a) {
                                    if (a === y) continue;
                                    return a
                                }
                            }
                            if ("next" === e.method) e.sent = e._sent = e.arg;
                            else if ("throw" === e.method) {
                                if (n === c) throw n = p, e.arg;
                                e.dispatchException(e.arg)
                            } else "return" === e.method && e.abrupt("return", e.arg);
                            n = l;
                            var f = s(t, r, e);
                            if ("normal" === f.type) {
                                if (n = e.done ? p : h, f.arg === y) continue;
                                return {
                                    value: f.arg,
                                    done: e.done
                                }
                            }
                            "throw" === f.type && (n = p, e.method = "throw", e.arg = f.arg)
                        }
                    }
                }(t, e, u), i
            }

            function s(t, r, e) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(r, e)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            t.wrap = f;
            var c = "suspendedStart",
                h = "suspendedYield",
                l = "executing",
                p = "completed",
                y = {};

            function g() {}

            function d() {}

            function v() {}
            var w = {};
            w[i] = function() {
                return this
            };
            var m = Object.getPrototypeOf,
                b = m && m(m(T([])));
            b && b !== e && n.call(b, i) && (w = b);
            var E = v.prototype = g.prototype = Object.create(w);

            function A(t) {
                ["next", "throw", "return"].forEach((function(r) {
                    t[r] = function(t) {
                        return this._invoke(r, t)
                    }
                }))
            }

            function _(t) {
                var r;
                this._invoke = function(e, o) {
                    function i() {
                        return new Promise((function(r, i) {
                            ! function r(e, o, i, u) {
                                var a = s(t[e], t, o);
                                if ("throw" !== a.type) {
                                    var f = a.arg,
                                        c = f.value;
                                    return c && "object" == typeof c && n.call(c, "__await") ? Promise.resolve(c.__await).then((function(t) {
                                        r("next", t, i, u)
                                    }), (function(t) {
                                        r("throw", t, i, u)
                                    })) : Promise.resolve(c).then((function(t) {
                                        f.value = t, i(f)
                                    }), (function(t) {
                                        return r("throw", t, i, u)
                                    }))
                                }
                                u(a.arg)
                            }(e, o, r, i)
                        }))
                    }
                    return r = r ? r.then(i, i) : i()
                }
            }

            function P(t, e) {
                var n = t.iterator[e.method];
                if (n === r) {
                    if (e.delegate = null, "throw" === e.method) {
                        if (t.iterator.return && (e.method = "return", e.arg = r, P(t, e), "throw" === e.method)) return y;
                        e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method")
                    }
                    return y
                }
                var o = s(n, t.iterator, e.arg);
                if ("throw" === o.type) return e.method = "throw", e.arg = o.arg, e.delegate = null, y;
                var i = o.arg;
                return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = r), e.delegate = null, y) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, y)
            }

            function x(t) {
                var r = {
                    tryLoc: t[0]
                };
                1 in t && (r.catchLoc = t[1]), 2 in t && (r.finallyLoc = t[2], r.afterLoc = t[3]), this.tryEntries.push(r)
            }

            function R(t) {
                var r = t.completion || {};
                r.type = "normal", delete r.arg, t.completion = r
            }

            function S(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(x, this), this.reset(!0)
            }

            function T(t) {
                if (t) {
                    var e = t[i];
                    if (e) return e.call(t);
                    if ("function" == typeof t.next) return t;
                    if (!isNaN(t.length)) {
                        var o = -1,
                            u = function e() {
                                for (; ++o < t.length;)
                                    if (n.call(t, o)) return e.value = t[o], e.done = !1, e;
                                return e.value = r, e.done = !0, e
                            };
                        return u.next = u
                    }
                }
                return {
                    next: B
                }
            }

            function B() {
                return {
                    value: r,
                    done: !0
                }
            }
            return d.prototype = E.constructor = v, v.constructor = d, v[a] = d.displayName = "GeneratorFunction", t.isGeneratorFunction = function(t) {
                var r = "function" == typeof t && t.constructor;
                return !!r && (r === d || "GeneratorFunction" === (r.displayName || r.name))
            }, t.mark = function(t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, v) : (t.__proto__ = v, a in t || (t[a] = "GeneratorFunction")), t.prototype = Object.create(E), t
            }, t.awrap = function(t) {
                return {
                    __await: t
                }
            }, A(_.prototype), _.prototype[u] = function() {
                return this
            }, t.AsyncIterator = _, t.async = function(r, e, n, o) {
                var i = new _(f(r, e, n, o));
                return t.isGeneratorFunction(e) ? i : i.next().then((function(t) {
                    return t.done ? t.value : i.next()
                }))
            }, A(E), E[a] = "Generator", E[i] = function() {
                return this
            }, E.toString = function() {
                return "[object Generator]"
            }, t.keys = function(t) {
                var r = [];
                for (var e in t) r.push(e);
                return r.reverse(),
                    function e() {
                        for (; r.length;) {
                            var n = r.pop();
                            if (n in t) return e.value = n, e.done = !1, e
                        }
                        return e.done = !0, e
                    }
            }, t.values = T, S.prototype = {
                constructor: S,
                reset: function(t) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = r, this.done = !1, this.delegate = null, this.method = "next", this.arg = r, this.tryEntries.forEach(R), !t)
                        for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = r)
                },
                stop: function() {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function(t) {
                    if (this.done) throw t;
                    var e = this;

                    function o(n, o) {
                        return a.type = "throw", a.arg = t, e.next = n, o && (e.method = "next", e.arg = r), !!o
                    }
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var u = this.tryEntries[i],
                            a = u.completion;
                        if ("root" === u.tryLoc) return o("end");
                        if (u.tryLoc <= this.prev) {
                            var f = n.call(u, "catchLoc"),
                                s = n.call(u, "finallyLoc");
                            if (f && s) {
                                if (this.prev < u.catchLoc) return o(u.catchLoc, !0);
                                if (this.prev < u.finallyLoc) return o(u.finallyLoc)
                            } else if (f) {
                                if (this.prev < u.catchLoc) return o(u.catchLoc, !0)
                            } else {
                                if (!s) throw new Error("try statement without catch or finally");
                                if (this.prev < u.finallyLoc) return o(u.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function(t, r) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var o = this.tryEntries[e];
                        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
                            var i = o;
                            break
                        }
                    }
                    i && ("break" === t || "continue" === t) && i.tryLoc <= r && r <= i.finallyLoc && (i = null);
                    var u = i ? i.completion : {};
                    return u.type = t, u.arg = r, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(u)
                },
                complete: function(t, r) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), y
                },
                finish: function(t) {
                    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                        var e = this.tryEntries[r];
                        if (e.finallyLoc === t) return this.complete(e.completion, e.afterLoc), R(e), y
                    }
                },
                catch: function(t) {
                    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                        var e = this.tryEntries[r];
                        if (e.tryLoc === t) {
                            var n = e.completion;
                            if ("throw" === n.type) {
                                var o = n.arg;
                                R(e)
                            }
                            return o
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function(t, e, n) {
                    return this.delegate = {
                        iterator: T(t),
                        resultName: e,
                        nextLoc: n
                    }, "next" === this.method && (this.arg = r), y
                }
            }, t
        }(t.exports);
        try {
            regeneratorRuntime = n
        } catch (t) {
            Function("r", "regeneratorRuntime = r")(n)
        }
    },
    29: function(t, r) {
        var e = {}.toString;
        t.exports = Array.isArray || function(t) {
            return "[object Array]" == e.call(t)
        }
    },
    39: function(t, r, e) {
        "use strict";
        r.byteLength = function(t) {
            var r = s(t),
                e = r[0],
                n = r[1];
            return 3 * (e + n) / 4 - n
        }, r.toByteArray = function(t) {
            for (var r, e = s(t), n = e[0], u = e[1], a = new i(function(t, r, e) {
                    return 3 * (r + e) / 4 - e
                }(0, n, u)), f = 0, c = u > 0 ? n - 4 : n, h = 0; h < c; h += 4) r = o[t.charCodeAt(h)] << 18 | o[t.charCodeAt(h + 1)] << 12 | o[t.charCodeAt(h + 2)] << 6 | o[t.charCodeAt(h + 3)], a[f++] = r >> 16 & 255, a[f++] = r >> 8 & 255, a[f++] = 255 & r;
            2 === u && (r = o[t.charCodeAt(h)] << 2 | o[t.charCodeAt(h + 1)] >> 4, a[f++] = 255 & r);
            1 === u && (r = o[t.charCodeAt(h)] << 10 | o[t.charCodeAt(h + 1)] << 4 | o[t.charCodeAt(h + 2)] >> 2, a[f++] = r >> 8 & 255, a[f++] = 255 & r);
            return a
        }, r.fromByteArray = function(t) {
            for (var r, e = t.length, o = e % 3, i = [], u = 0, a = e - o; u < a; u += 16383) i.push(c(t, u, u + 16383 > a ? a : u + 16383));
            1 === o ? (r = t[e - 1], i.push(n[r >> 2] + n[r << 4 & 63] + "==")) : 2 === o && (r = (t[e - 2] << 8) + t[e - 1], i.push(n[r >> 10] + n[r >> 4 & 63] + n[r << 2 & 63] + "="));
            return i.join("")
        };
        for (var n = [], o = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, f = u.length; a < f; ++a) n[a] = u[a], o[u.charCodeAt(a)] = a;

        function s(t) {
            var r = t.length;
            if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
            var e = t.indexOf("=");
            return -1 === e && (e = r), [e, e === r ? 0 : 4 - e % 4]
        }

        function c(t, r, e) {
            for (var o, i, u = [], a = r; a < e; a += 3) o = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]), u.push(n[(i = o) >> 18 & 63] + n[i >> 12 & 63] + n[i >> 6 & 63] + n[63 & i]);
            return u.join("")
        }
        o["-".charCodeAt(0)] = 62, o["_".charCodeAt(0)] = 63
    },
    4: function(t, r) {
        t.exports = function(t, r) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function")
        }
    },
    40: function(t, r) {
        r.read = function(t, r, e, n, o) {
            var i, u, a = 8 * o - n - 1,
                f = (1 << a) - 1,
                s = f >> 1,
                c = -7,
                h = e ? o - 1 : 0,
                l = e ? -1 : 1,
                p = t[r + h];
            for (h += l, i = p & (1 << -c) - 1, p >>= -c, c += a; c > 0; i = 256 * i + t[r + h], h += l, c -= 8);
            for (u = i & (1 << -c) - 1, i >>= -c, c += n; c > 0; u = 256 * u + t[r + h], h += l, c -= 8);
            if (0 === i) i = 1 - s;
            else {
                if (i === f) return u ? NaN : 1 / 0 * (p ? -1 : 1);
                u += Math.pow(2, n), i -= s
            }
            return (p ? -1 : 1) * u * Math.pow(2, i - n)
        }, r.write = function(t, r, e, n, o, i) {
            var u, a, f, s = 8 * i - o - 1,
                c = (1 << s) - 1,
                h = c >> 1,
                l = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                p = n ? 0 : i - 1,
                y = n ? 1 : -1,
                g = r < 0 || 0 === r && 1 / r < 0 ? 1 : 0;
            for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (a = isNaN(r) ? 1 : 0, u = c) : (u = Math.floor(Math.log(r) / Math.LN2), r * (f = Math.pow(2, -u)) < 1 && (u--, f *= 2), (r += u + h >= 1 ? l / f : l * Math.pow(2, 1 - h)) * f >= 2 && (u++, f /= 2), u + h >= c ? (a = 0, u = c) : u + h >= 1 ? (a = (r * f - 1) * Math.pow(2, o), u += h) : (a = r * Math.pow(2, h - 1) * Math.pow(2, o), u = 0)); o >= 8; t[e + p] = 255 & a, p += y, a /= 256, o -= 8);
            for (u = u << o | a, s += o; s > 0; t[e + p] = 255 & u, p += y, u /= 256, s -= 8);
            t[e + p - y] |= 128 * g
        }
    },
    5: function(t, r) {
        function e(t, r) {
            for (var e = 0; e < r.length; e++) {
                var n = r[e];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }
        t.exports = function(t, r, n) {
            return r && e(t.prototype, r), n && e(t, n), t
        }
    },
    6: function(t, r, e) {
        var n = e(13),
            o = e(23);
        t.exports = function(t, r) {
            return !r || "object" !== n(r) && "function" != typeof r ? o(t) : r
        }
    },
    7: function(t, r) {
        var e;
        e = function() {
            return this
        }();
        try {
            e = e || new Function("return this")()
        } catch (t) {
            "object" == typeof window && (e = window)
        }
        t.exports = e
    },
    8: function(t, r) {
        function e(r) {
            return t.exports = e = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, e(r)
        }
        t.exports = e
    },
    9: function(t, r, e) {
        var n = e(24);
        t.exports = function(t, r) {
            if ("function" != typeof r && null !== r) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(r && r.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), r && n(t, r)
        }
    }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcGx1Z2luLWVvc2pzMi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiU2NhdHRlckpTXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiXSwibmFtZXMiOlsiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJpIiwibCIsIm1vZHVsZXMiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJhcmciLCJpbmZvIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJmbiIsInNlbGYiLCJ0aGlzIiwiYXJncyIsImFyZ3VtZW50cyIsImFwcGx5IiwiZXJyIiwidW5kZWZpbmVkIiwiYmFzZTY0IiwiaWVlZTc1NCIsImlzQXJyYXkiLCJrTWF4TGVuZ3RoIiwiQnVmZmVyIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImNyZWF0ZUJ1ZmZlciIsInRoYXQiLCJsZW5ndGgiLCJSYW5nZUVycm9yIiwiVWludDhBcnJheSIsIl9fcHJvdG9fXyIsImVuY29kaW5nT3JPZmZzZXQiLCJFcnJvciIsImFsbG9jVW5zYWZlIiwiZnJvbSIsIlR5cGVFcnJvciIsIkFycmF5QnVmZmVyIiwiYXJyYXkiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImZyb21BcnJheUxpa2UiLCJmcm9tQXJyYXlCdWZmZXIiLCJzdHJpbmciLCJlbmNvZGluZyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJ3cml0ZSIsInNsaWNlIiwiZnJvbVN0cmluZyIsIm9iaiIsImlzQnVmZmVyIiwibGVuIiwiY2hlY2tlZCIsImNvcHkiLCJidWZmZXIiLCJ2YWwiLCJ0eXBlIiwiZGF0YSIsImZyb21PYmplY3QiLCJhc3NlcnRTaXplIiwic2l6ZSIsInRvU3RyaW5nIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJ0b0xvd2VyQ2FzZSIsInNsb3dUb1N0cmluZyIsInN0YXJ0IiwiZW5kIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJiIiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJkaXIiLCJpc05hTiIsImFycmF5SW5kZXhPZiIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImFyciIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsIlN0cmluZyIsInJlYWQiLCJidWYiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJqIiwiaGV4V3JpdGUiLCJvZmZzZXQiLCJOdW1iZXIiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZWQiLCJwYXJzZUludCIsInN1YnN0ciIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwic3RyIiwiYnl0ZUFycmF5IiwicHVzaCIsImNoYXJDb2RlQXQiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidW5pdHMiLCJoaSIsImxvIiwidXRmMTZsZVRvQnl0ZXMiLCJmcm9tQnl0ZUFycmF5IiwiTWF0aCIsIm1pbiIsInJlcyIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJjb2RlUG9pbnRzIiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJmcm9tQ2hhckNvZGUiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJTbG93QnVmZmVyIiwiYWxsb2MiLCJJTlNQRUNUX01BWF9CWVRFUyIsImdsb2JhbCIsImZvbyIsInN1YmFycmF5IiwiZSIsInR5cGVkQXJyYXlTdXBwb3J0IiwicG9vbFNpemUiLCJfYXVnbWVudCIsInNwZWNpZXMiLCJjb25maWd1cmFibGUiLCJmaWxsIiwiYWxsb2NVbnNhZmVTbG93IiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsImEiLCJ4IiwieSIsImNvbmNhdCIsImxpc3QiLCJwb3MiLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJlcXVhbHMiLCJpbnNwZWN0IiwibWF4IiwibWF0Y2giLCJqb2luIiwidGFyZ2V0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImluY2x1ZGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJBcnJheSIsIl9hcnIiLCJyZXQiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwiY2hlY2tPZmZzZXQiLCJleHQiLCJjaGVja0ludCIsIm9iamVjdFdyaXRlVUludDE2IiwibGl0dGxlRW5kaWFuIiwib2JqZWN0V3JpdGVVSW50MzIiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwibm9Bc3NlcnQiLCJ3cml0ZURvdWJsZSIsIm5ld0J1ZiIsInNsaWNlTGVuIiwicmVhZFVJbnRMRSIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsIndyaXRlVUludExFIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4IiwiZmxvb3IiLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsImxpbWl0Iiwic3ViIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJzZXQiLCJjb2RlIiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJJbmZpbml0eSIsImxlYWRTdXJyb2dhdGUiLCJ0b0J5dGVBcnJheSIsInRyaW0iLCJyZXBsYWNlIiwic3RyaW5ndHJpbSIsImJhc2U2NGNsZWFuIiwic3JjIiwiZHN0IiwiX3R5cGVvZjIiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwiX3R5cGVvZiIsInNvY2tldFNlcnZpY2UiLCJTb2NrZXRTZXJ2aWNlIiwicHJveHkiLCJkdW1teSIsImhhbmRsZXIiLCJQcm94eSIsIlNjYXR0ZXJFT1MiLCJCbG9ja2NoYWlucyIsIkVPUyIsIlBsdWdpblR5cGVzIiwiQkxPQ0tDSEFJTl9TVVBQT1JUIiwiX3MiLCJuZXR3b3JrIiwiZmllbGRzRmV0Y2hlciIsIk5ldHdvcmsiLCJmcm9tSnNvbiIsInJlcXVpcmVkRmllbGRzIiwiZ2V0QXZhaWxhYmxlS2V5cyIsInNlbmRBcGlSZXF1ZXN0IiwicGF5bG9hZCIsImlkIiwiYWNjb3VudHMiLCJmaWx0ZXIiLCJibG9ja2NoYWluIiwibWFwIiwicHVibGljS2V5Iiwic2lnbiIsInNpZ25hcmdzIiwic2VyaWFsaXplZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJzaWduYXR1cmVzIiwic2lnbmVycyIsInNjYXR0ZXJTaWduZXIiLCJlb3NIb29rIiwic2NhdHRlcktleXMiLCJvdGhlcktleXMiLCJhbGwiLCJzaWduZXIiLCJrZXlzIiwiaW5kaXZpZHVhbFNpZ25BcmdzIiwicHJvdmlkZXIiLCJhYmlzIiwiY2hhaW5JZCIsInJlcXVpcmVkS2V5cyIsInB1bGxPdXRTaWduYXR1cmVzIiwicmVzdWx0Iiwic2NhdHRlclNpZ3MiLCJvdGhlclNpZ3MiLCJzaWciLCJfYXBpIiwiX29wdGlvbnMiLCJzaWduYXR1cmVQcm92aWRlciIsImhvb2tQcm92aWRlciIsImFzc2lnbiIsImVvc0luc3RhbmNlIiwibWV0aG9kIiwicnFmIiwiZmluZCIsIlBsdWdpbiIsIndpbmRvdyIsIlNjYXR0ZXJKUyIsIlJlZmVyZW5jZUVycm9yIiwiX3NldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJydW50aW1lIiwiT3AiLCJoYXNPd24iLCIkU3ltYm9sIiwiaXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwid3JhcCIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsImNvbnRleHQiLCJDb250ZXh0IiwiX2ludm9rZSIsInN0YXRlIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlRXhlY3V0aW5nIiwiR2VuU3RhdGVDb21wbGV0ZWQiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJDb250aW51ZVNlbnRpbmVsIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJyZWNvcmQiLCJ0cnlDYXRjaCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJtYWtlSW52b2tlTWV0aG9kIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwiQXN5bmNJdGVyYXRvciIsInByZXZpb3VzUHJvbWlzZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiaW52b2tlIiwiX19hd2FpdCIsInVud3JhcHBlZCIsInJlc3VsdE5hbWUiLCJuZXh0IiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJlbnRyeSIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInJlc2V0VHJ5RW50cnkiLCJjb21wbGV0aW9uIiwicmVzZXQiLCJpdGVyYWJsZSIsIml0ZXJhdG9yTWV0aG9kIiwiZGlzcGxheU5hbWUiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiY3RvciIsIm1hcmsiLCJhd3JhcCIsImFzeW5jIiwiaXRlciIsInJldmVyc2UiLCJwb3AiLCJza2lwVGVtcFJlc2V0IiwicHJldiIsImNoYXJBdCIsInN0b3AiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiRnVuY3Rpb24iLCJiNjQiLCJsZW5zIiwiZ2V0TGVucyIsInZhbGlkTGVuIiwicGxhY2VIb2xkZXJzTGVuIiwidG1wIiwiQXJyIiwiX2J5dGVMZW5ndGgiLCJjdXJCeXRlIiwicmV2TG9va3VwIiwidWludDgiLCJleHRyYUJ5dGVzIiwicGFydHMiLCJsZW4yIiwiZW5jb2RlQ2h1bmsiLCJsb29rdXAiLCJudW0iLCJvdXRwdXQiLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiaXNMRSIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJOYU4iLCJydCIsImFicyIsImxvZyIsIkxOMiIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwid3JpdGFibGUiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJnIiwiX2dldFByb3RvdHlwZU9mIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIl0sIm1hcHBpbmdzIjoiYUFDRSxJQUFJQSxFQUFtQixHQUd2QixTQUFTQyxFQUFvQkMsR0FHNUIsR0FBR0YsRUFBaUJFLEdBQ25CLE9BQU9GLEVBQWlCRSxHQUFVQyxRQUduQyxJQUFJQyxFQUFTSixFQUFpQkUsR0FBWSxDQUN6Q0csRUFBR0gsRUFDSEksR0FBRyxFQUNISCxRQUFTLElBVVYsT0FOQUksRUFBUUwsR0FBVU0sS0FBS0osRUFBT0QsUUFBU0MsRUFBUUEsRUFBT0QsUUFBU0YsR0FHL0RHLEVBQU9FLEdBQUksRUFHSkYsRUFBT0QsUUFLZkYsRUFBb0JRLEVBQUlGLEVBR3hCTixFQUFvQlMsRUFBSVYsRUFHeEJDLEVBQW9CVSxFQUFJLFNBQVNSLEVBQVNTLEVBQU1DLEdBQzNDWixFQUFvQmEsRUFBRVgsRUFBU1MsSUFDbENHLE9BQU9DLGVBQWViLEVBQVNTLEVBQU0sQ0FBRUssWUFBWSxFQUFNQyxJQUFLTCxLQUtoRVosRUFBb0JrQixFQUFJLFNBQVNoQixHQUNYLG9CQUFYaUIsUUFBMEJBLE9BQU9DLGFBQzFDTixPQUFPQyxlQUFlYixFQUFTaUIsT0FBT0MsWUFBYSxDQUFFQyxNQUFPLFdBRTdEUCxPQUFPQyxlQUFlYixFQUFTLGFBQWMsQ0FBRW1CLE9BQU8sS0FRdkRy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RUFBUW5SLElBQXNDLG1CQUFUQSxFQUkzQzJkLEVBQXNCamIsR0FIcEIxQyxJLGdCQ05YLElBQUk0ZCxFQUdKQSxFQUFJLFdBQ0gsT0FBT2piLEtBREosR0FJSixJQUVDaWIsRUFBSUEsR0FBSyxJQUFJeEMsU0FBUyxjQUFiLEdBQ1IsTUFBTzNRLEdBRWMsaUJBQVhzSyxTQUFxQjZJLEVBQUk3SSxRQU9yQ25WLEVBQU9ELFFBQVVpZSxHLGdCQ25CakIsU0FBU0MsRUFBZ0J2ZCxHQUl2QixPQUhBVixFQUFPRCxRQUFVa2UsRUFBa0J0ZCxPQUFPNFUsZUFBaUI1VSxPQUFPb1gsZUFBaUIsU0FBeUJyWCxHQUMxRyxPQUFPQSxFQUFFc0QsV0FBYXJELE9BQU9vWCxlQUFlclgsSUFFdkN1ZCxFQUFnQnZkLEdBR3pCVixFQUFPRCxRQUFVa2UsRyxrQkNQakIsSUFBSTFJLEVBQWlCLEVBQVEsSUFpQjdCdlYsRUFBT0QsUUFmUCxTQUFtQm1lLEVBQVVDLEdBQzNCLEdBQTBCLG1CQUFmQSxHQUE0QyxPQUFmQSxFQUN0QyxNQUFNLElBQUk5WixVQUFVLHNEQUd0QjZaLEVBQVNyYyxVQUFZbEIsT0FBT1ksT0FBTzRjLEdBQWNBLEVBQVd0YyxVQUFXLENBQ3JFeVAsWUFBYSxDQUNYcFEsTUFBT2dkLEVBQ1BOLFVBQVUsRUFDVjFTLGNBQWMsS0FHZGlULEdBQVk1SSxFQUFlMkksRUFBVUMiLCJmaWxlIjoic2NhdHRlcmpzLXBsdWdpbi1lb3NqczIubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDE0MCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YyKG9iaik7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwiaW1wb3J0IHtcclxuXHRQbHVnaW4sXHJcblx0UGx1Z2luVHlwZXMsXHJcblx0QmxvY2tjaGFpbnMsXHJcblx0TmV0d29yayxcclxuXHRTb2NrZXRTZXJ2aWNlXHJcbn0gZnJvbSAnQHNjYXR0ZXJqcy9jb3JlJztcclxuXHJcbmxldCBzb2NrZXRTZXJ2aWNlID0gU29ja2V0U2VydmljZTtcclxuY29uc3QgcHJveHkgPSAoZHVtbXksIGhhbmRsZXIpID0+IG5ldyBQcm94eShkdW1teSwgaGFuZGxlcik7XHJcbmxldCBjYWNoZSA9IHt9O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhdHRlckVPUyBleHRlbmRzIFBsdWdpbiB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihCbG9ja2NoYWlucy5FT1MsIFBsdWdpblR5cGVzLkJMT0NLQ0hBSU5fU1VQUE9SVCk7XHJcbiAgICB9XHJcblxyXG5cdHNldFNvY2tldFNlcnZpY2UoX3Mpe1xyXG5cdFx0c29ja2V0U2VydmljZSA9IF9zO1xyXG5cdH1cclxuXHJcbiAgICBob29rUHJvdmlkZXIobmV0d29yaywgZmllbGRzRmV0Y2hlciA9IG51bGwpe1xyXG4gICAgICAgIG5ldHdvcmsgPSBOZXR3b3JrLmZyb21Kc29uKG5ldHdvcmspO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXF1aXJlZEZpZWxkczp7fSxcclxuICAgICAgICAgICAgZ2V0QXZhaWxhYmxlS2V5czphc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgc29ja2V0U2VydmljZS5zZW5kQXBpUmVxdWVzdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTonaWRlbnRpdHlGcm9tUGVybWlzc2lvbnMnLFxyXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6e31cclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oaWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFpZCkgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZC5hY2NvdW50cy5maWx0ZXIoeCA9PiB4LmJsb2NrY2hhaW4gPT09IEJsb2NrY2hhaW5zLkVPUykubWFwKHggPT4geC5wdWJsaWNLZXkpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNpZ246YXN5bmMgKHNpZ25hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IGZpZWxkc0ZldGNoZXIgPyBmaWVsZHNGZXRjaGVyKCkgOiB7fTtcclxuICAgICAgICAgICAgICAgIHNpZ25hcmdzLnNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IEJ1ZmZlci5mcm9tKHNpZ25hcmdzLnNlcmlhbGl6ZWRUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2hleCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblx0ICAgICAgICAgICAgICAgIHNvY2tldFNlcnZpY2Uuc2VuZEFwaVJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOidyZXF1ZXN0U2lnbmF0dXJlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDp7IHRyYW5zYWN0aW9uOnNpZ25hcmdzLCBibG9ja2NoYWluOkJsb2NrY2hhaW5zLkVPUywgbmV0d29yaywgcmVxdWlyZWRGaWVsZHMgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oeCA9PiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtzaWduYXR1cmVzOnguc2lnbmF0dXJlcywgc2VyaWFsaXplZFRyYW5zYWN0aW9uOkJ1ZmZlci5mcm9tKHNpZ25hcmdzLnNlcmlhbGl6ZWRUcmFuc2FjdGlvbiwgJ2hleCcpfSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHggPT4gcmVqZWN0KHgpKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBtdWx0aUhvb2sobmV0d29yaywgc2lnbmVycyl7XHJcbiAgICAgICAgY29uc3Qgc2NhdHRlclNpZ25lciA9IHRoaXMuZW9zSG9vayhuZXR3b3JrKTtcclxuXHJcbiAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkoc2lnbmVycykpIHNpZ25lcnMgPSBbc2lnbmVyc107XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldEF2YWlsYWJsZUtleXM6YXN5bmMgKCkgPT4ge1xyXG5cdCAgICAgICAgICAgIHRyeSB7XHJcblx0XHQgICAgICAgICAgICBjb25zdCBzY2F0dGVyS2V5cyA9IGF3YWl0IHNjYXR0ZXJTaWduZXIuZ2V0QXZhaWxhYmxlS2V5cygpO1xyXG5cclxuXHRcdCAgICAgICAgICAgIGxldCBvdGhlcktleXMgPSBbXTtcclxuXHRcdCAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHNpZ25lcnMubWFwKGFzeW5jIHNpZ25lciA9PiB7XHJcblx0XHRcdCAgICAgICAgICAgIGF3YWl0IHNpZ25lci5nZXRBdmFpbGFibGVLZXlzKCkudGhlbihrZXlzID0+IHtcclxuXHRcdFx0XHQgICAgICAgICAgICBrZXlzLm1hcChrZXkgPT4gb3RoZXJLZXlzLnB1c2goa2V5KSk7XHJcblx0XHRcdCAgICAgICAgICAgIH0pO1xyXG5cdFx0ICAgICAgICAgICAgXHRyZXR1cm4gdHJ1ZTtcclxuXHRcdCAgICAgICAgICAgIH0pKTtcclxuXHJcblx0XHQgICAgICAgICAgICByZXR1cm4gc2NhdHRlcktleXMuY29uY2F0KG90aGVyS2V5cylcclxuXHQgICAgICAgICAgICB9IGNhdGNoKGUpe1xyXG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNpZ246YXN5bmMgKHNpZ25hcmdzKSA9PiB7XHJcblx0ICAgICAgICAgICAgdHJ5IHtcclxuXHRcdCAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IEJ1ZmZlci5mcm9tKHNpZ25hcmdzLnNlcmlhbGl6ZWRUcmFuc2FjdGlvbiwgJ2hleCcpO1xyXG5cclxuXHRcdCAgICAgICAgICAgIGNvbnN0IGluZGl2aWR1YWxTaWduQXJncyA9IGFzeW5jIHByb3ZpZGVyID0+ICh7XHJcblx0XHRcdCAgICAgICAgICAgIGFiaXM6c2lnbmFyZ3MuYWJpcyxcclxuXHRcdFx0ICAgICAgICAgICAgY2hhaW5JZDogbmV0d29yay5jaGFpbklkLFxyXG5cdFx0XHQgICAgICAgICAgICByZXF1aXJlZEtleXM6IGF3YWl0IHByb3ZpZGVyLmdldEF2YWlsYWJsZUtleXMoKSxcclxuXHRcdFx0ICAgICAgICAgICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uXHJcblx0XHQgICAgICAgICAgICB9KTtcclxuXHJcblx0XHQgICAgICAgICAgICBjb25zdCBwdWxsT3V0U2lnbmF0dXJlcyA9IHJlc3VsdCA9PiB7XHJcblx0XHRcdCAgICAgICAgICAgIGlmKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdC5oYXNPd25Qcm9wZXJ0eSgnc2lnbmF0dXJlcycpKSByZXR1cm4gcmVzdWx0LnNpZ25hdHVyZXM7XHJcblx0XHRcdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0XHQgICAgICAgICAgICB9O1xyXG5cclxuXHRcdCAgICAgICAgICAgIGNvbnN0IHNjYXR0ZXJTaWdzID0gYXdhaXQgc2NhdHRlclNpZ25lclxyXG5cdFx0XHQgICAgICAgICAgICAuc2lnbihhd2FpdCBpbmRpdmlkdWFsU2lnbkFyZ3Moc2NhdHRlclNpZ25lcikpXHJcblx0XHRcdCAgICAgICAgICAgIC50aGVuKHggPT4gcHVsbE91dFNpZ25hdHVyZXMoeCkpO1xyXG5cclxuXHRcdCAgICAgICAgICAgIGxldCBvdGhlclNpZ3MgPSBbXTtcclxuXHRcdCAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHNpZ25lcnMubWFwKGFzeW5jIHNpZ25lciA9PiB7XHJcblx0XHRcdCAgICAgICAgICAgIGF3YWl0IHNpZ25lci5zaWduKGF3YWl0IGluZGl2aWR1YWxTaWduQXJncyhzaWduZXIpKS50aGVuKHJlc3VsdCA9PiB7XHJcblx0XHRcdFx0ICAgICAgICAgICAgcHVsbE91dFNpZ25hdHVyZXMocmVzdWx0KS5tYXAoc2lnID0+IG90aGVyU2lncy5wdXNoKHNpZykpO1xyXG5cdFx0XHQgICAgICAgICAgICB9KTtcclxuXHRcdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0XHQgICAgICAgICAgICB9KSk7XHJcblxyXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHRcdFx0ICAgICAgICAgICAgc2lnbmF0dXJlczogc2NhdHRlclNpZ3MuY29uY2F0KG90aGVyU2lncyksXHJcblx0XHRcdCAgICAgICAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvblxyXG5cdFx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH0gY2F0Y2goZSl7XHJcblx0ICAgICAgICAgICAgXHR0aHJvdyBuZXcgRXJyb3IoZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNpZ25hdHVyZVByb3ZpZGVyKC4uLmFyZ3Mpe1xyXG5cclxuICAgICAgICBjb25zdCB0aHJvd0lmTm9JZGVudGl0eSA9IGFyZ3NbMF07XHJcblxyXG4gICAgICAgIC8vIFByb3RvY29sIHdpbGwgYmUgZGVwcmVjYXRlZC5cclxuICAgICAgICByZXR1cm4gKG5ldHdvcmssIF9hcGksIF9vcHRpb25zID0ge30pID0+IHtcclxuXHJcbiAgICAgICAgICAgIG5ldHdvcmsgPSBOZXR3b3JrLmZyb21Kc29uKG5ldHdvcmspO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlcXVpcmVkRmllbGRzID0ge307XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkc0ZldGNoZXIgPSAoKSA9PiByZXF1aXJlZEZpZWxkcztcclxuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlUHJvdmlkZXIgPSB0aGlzLmhvb2tQcm92aWRlcihuZXR3b3JrLCBmaWVsZHNGZXRjaGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBwcm94eSBzdGFuZHMgYmV0d2VlbiB0aGUgZW9zanMgb2JqZWN0IGFuZCBzY2F0dGVyLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gYWRkIHNwZWNpYWwgZnVuY3Rpb25hbGl0eSBsaWtlIGFkZGluZyBgcmVxdWlyZWRGaWVsZHNgIGFycmF5cyB0byB0cmFuc2FjdGlvbnNcclxuICAgICAgICAgICAgcmV0dXJuIHByb3h5KG5ldyBfYXBpKE9iamVjdC5hc3NpZ24oX29wdGlvbnMsIHtzaWduYXR1cmVQcm92aWRlcn0pKSwge1xyXG4gICAgICAgICAgICAgICAgZ2V0KGVvc0luc3RhbmNlLCBtZXRob2QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHRpZih0eXBlb2YgZW9zSW5zdGFuY2VbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7bWV0aG9kfSBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZW9zanMuQXBpKCkgb2JqZWN0LmApXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJxZiA9IGFyZ3MuZmluZChhcmcgPT4gYXJnLmhhc093blByb3BlcnR5KCdyZXF1aXJlZEZpZWxkcycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRGaWVsZHMgPSBycWYgPyBycWYucmVxdWlyZWRGaWVsZHMgOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVvc0luc3RhbmNlW21ldGhvZF0oLi4uYXJncylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pOyAvLyBQcm94eVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0d2luZG93LlNjYXR0ZXJFT1MgPSBTY2F0dGVyRU9TO1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gU2NhdHRlckpTOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiXSwic291cmNlUm9vdCI6IiJ9